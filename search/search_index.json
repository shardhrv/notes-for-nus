{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my notes!","text":"<p>Hi! Here are some notes that I have made. You can use these to supplement your revision. Happy grinding!</p>"},{"location":"#courses","title":"Courses","text":"<ol> <li>CS2040S Home Page</li> <li>IS1108 Home Page</li> <li>coming soon...</li> </ol>"},{"location":"CS2040S/1-dimension%20Peak%20Finding/","title":"1 dimension Peak Finding","text":"<p>CS2040S Home Page | Peak Finding</p>"},{"location":"CS2040S/1-dimension%20Peak%20Finding/#find-peaks","title":"Find Peaks","text":"<p>Find Peak</p>"},{"location":"CS2040S/1-dimension%20Peak%20Finding/#steep-peaks","title":"Steep Peaks","text":"<p>Steep Peaks</p>"},{"location":"CS2040S/2-dimension%20Peak%20Finding/","title":"2 dimension Peak Finding","text":"<p>CS2040S Home Page | Peak Finding</p> <p>Given: 2D Array <code>A[1...n, 1...m]</code></p> <p></p> <p>Output: a peak that is not smaller than (at most) 4 of its neighbours</p>"},{"location":"CS2040S/2-dimension%20Peak%20Finding/#linear-search-amended-to-2d","title":"Linear Search - Amended to 2D","text":"<p>Step 1: Find a global peak in each column --&gt; \\(O(n)\\) Step 2: Find a global peak amongst the peak in each column --&gt; \\(O(m)\\)</p> <p>Runs in \\(O(nm)\\)!</p>"},{"location":"CS2040S/2-dimension%20Peak%20Finding/#divide-and-conquer-implementation-binary-search","title":"Divide and Conquer Implementation (Binary Search)","text":"<p>Step 1: Use Linear Search to find max in one column --&gt; \\(O(n)\\) Step 2: Compare the element left and right of the found max --&gt; \\(O(1)\\) Step 3: Recurse left / right using the same conditions as the 1D Find peak --&gt; \\(O(log(m))\\)</p> <p>Runtime: \\(O(nlog(m))\\)</p>"},{"location":"CS2040S/2-dimension%20Peak%20Finding/#reduce-and-conquer-implementation","title":"Reduce and Conquer Implementation","text":"<p>Follow these MIT slides for a swift overview</p> <p>Broken down into these steps: Step 1: Find MAX element (g) in the border and cross (purple). If it is a peak, DONE.</p> <p></p> <p>Step 2: If it is not, recurse on quadrant with the element bigger than g (h).</p>"},{"location":"CS2040S/2-dimension%20Peak%20Finding/#proof","title":"Proof","text":""},{"location":"CS2040S/2-dimension%20Peak%20Finding/#correctness","title":"Correctness:","text":"<ol> <li>The quadrant contains a peak. If there is no peak, then you can find an increasing path that keeps going until you either find a maximum element (a peak) or it exits the quadrant.</li> <li>Every peak in the quadrant is NOT a peak in the matrix. (pictured below)</li> <li>Key property: Find a peak at least as large as every element on the boundary.</li> </ol>"},{"location":"CS2040S/2-dimension%20Peak%20Finding/#resources","title":"Resources","text":"<p>Find Peak in 2D Array </p>"},{"location":"CS2040S/Algorithmic%20Analysis/","title":"Algorithmic Analysis","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#algorithms","title":"Algorithms","text":"<p>For every algorithm, the following must be understood: - What problem does this algorithm solve? - When can this algorithm be applied?      - ie What are the preconditions and when does this algorithm fail? - Why is the algorithm correct? - What is the key invariant behind the algorithm? - What is the running time of the algorithm? - What optimisations are possible?</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#preconditions-and-postconditions","title":"Preconditions and Postconditions","text":"<p>Precondition: - Something that is true when the function begins - Something important for it to work correctly Postcondition: - Fact that is true when the function ends - Something useful to show that the computation was done correctly</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#big-o-notation","title":"Big-O Notation","text":"<p>Always think big</p> <p>Precise definition: \\(T(n) = O(f(n))\\) if T grows no faster than f     \\(T(n) = O(f(n))\\) if:     - there exists a constant \\(c &gt; 0\\)     - there exists a constant \\(n_{0} &gt; 0\\) such that for all \\(n &gt; n_{0}\\):     \\(T(n) \\leq cf(n)\\)</p> <p></p> <p>In English: Worst-Case performance of the algorithm can be tightly bounded by \\(O(f(n))\\)</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#big-omega-notation","title":"Big-Omega Notation","text":"<p>Precise definition: \\(T(n) = \\Omega(f(n))\\) if T grows no slower than f     \\(T(n) = \\Omega(f(n))\\) if:     - there exists a constant \\(c &gt; 0\\)     - there exists a constant \\(n_{0} &gt; 0\\) such that for all \\(n &gt; n_{0}\\):     \\(T(n) \\geq cf(n)\\)</p> <p>In English: Best-Case performance of the algorithm can be tightly bounded by \\(\\Omega(f(n))\\)</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#big-theta-notation","title":"Big-Theta Notation","text":"<p>Precise definition: \\(T(n) = \\Theta(f(n))\\) if T grows at the same rate as f     \\(T(n) = \\Theta(f(n))\\) if:     - \\(T(n) = O(f(n))\\) and      - \\(T(n) = \\Omega(f(n))\\)</p> <p>In English: Expected performance of the algorithm can be tightly bounded by \\(\\Theta(f(n))\\)</p> <p>Always think tight</p> <ul> <li>Choose the tightest bound that you can find</li> </ul>"},{"location":"CS2040S/Algorithmic%20Analysis/#order-or-size","title":"Order or size","text":"<p>Quick look-up table:</p> <p></p>"},{"location":"CS2040S/Algorithmic%20Analysis/#big-o-rules","title":"Big-O Rules","text":"<p>If \\(T(n) = O(f(n))\\) and \\(S(n) = O(g(n))\\) then \\(T(n) + S(n) = O(f(n) + g(n))\\) If \\(T(n) = O(f(n))\\) and \\(S(n) = O(g(n))\\) then \\(T(n) * S(n) = O(f(n) * g(n))\\)</p> <p>Note: \\(O(n!) = O(nlogn)\\)</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#algorithmic-analysis-rules","title":"Algorithmic Analysis Rules","text":"<p>Suppose we have the code <pre><code>void sum(int k, int[] intArray) {\n    int total = 0;\n    for (int 1 = 0; i &lt;= k; i++) {\n        total += intArray[i];\n    }\n    return total;\n}\n</code></pre></p>"},{"location":"CS2040S/Algorithmic%20Analysis/#what-is-the-cost-of-running-this-excerpt","title":"What is the cost of running this excerpt?","text":"<p>There are many ways of doing it, but it all depends on what we are trying to analyse. If we wanted, we could look at each assignment as adding to the cost, or each increment as another operation. But just because something is more specific, does not mean it is more useful. Always thing about what the target of your analysis is!</p>"},{"location":"CS2040S/Algorithmic%20Analysis/#how-can-we-calculate-cost","title":"How can we calculate cost?","text":"<p>Loops \\(cost = (n-iterations) * (max(one-iteration))\\) Nested-Loops \\(cost = (n-iterations) * (max(one-iteration))\\) Sequential Statements  \\(cost = a_{cost} + b_{cost}\\) Conditional statements \\(cost = max(a_{cost}, b_{cost}) \\leq (a_{cost} + b_{cost})\\) Recursive calls (spooky) Recursion relations need to be analysed. See Common Recurrence Relations</p>"},{"location":"CS2040S/Balanced%20Trees/","title":"Balanced Trees","text":""},{"location":"CS2040S/Balanced%20Trees/#definition","title":"Definition","text":"<p>The smallest possible height for a tree is \\(O(log(n))\\). On a balanced tree, all operations run in \\(O(log(n))\\) time. The definition for a balanced tree is loosened slightly to be a tree whose subtree's heights differ at most by 1.  </p>"},{"location":"CS2040S/Binary%20Search%20Trees%20%28BST%29/","title":"Binary Search Trees (BST)","text":"<p>CS2040S Home Page | Data Structures | Trees | Binary Trees</p>"},{"location":"CS2040S/Binary%20Search%20Trees%20%28BST%29/#bst-property","title":"BST Property","text":"<p>All nodes in left subtree &lt; current Node &lt; all nodes in right subtree</p>"},{"location":"CS2040S/Binary%20Search%20Trees%20%28BST%29/#operations","title":"Operations","text":"<p>Search for maximum key: Largest key in the BST. Take advantage of the fact that in BST, the larger element is always on the right. \\(O(height)\\)</p> <pre><code>public TreeNode getMax() {\n    if (this.rightChild == null) {\n        return this;\n    } else {\n        return getMax(this.rightChild.getMax());\n    }\n}\n</code></pre> <p>Search for minimum key: Smallest key in the BST. Similar to above, but on the left! \\(O(log(n))\\) <pre><code>public TreeNode getMin() {\n    if (this.leftChild == null) {\n        return this;\n    } else {\n        return getMax(this.leftChild.getMin());\n    }\n}\n</code></pre></p> <p>Search: Find a key k! \\(O(height)\\) <pre><code>public TreeNode search(Key k) {\n    if (this.key == k) {\n        return this;\n    } \n\n    if (this.leftChild == null and this.rightChild == null) {\n        return null; // not found!\n    }\n\n    if (k &lt; this.key) {\n        this.leftChild.search(k);\n    } else {\n        this.rightChild.search(k);\n    }\n}\n</code></pre></p> <p>Insert: Add a node! \\(O(height)\\) <pre><code>public void insert(TreeNode node) {\n    if (node.key &lt; this.key) {\n        if (this.leftChild == null) {\n            this.leftChild == node;\n        } else {\n            this.leftChild.insert(node);\n        }\n    } else if (node.key &gt; this.key) {\n        if (this.rightChild == null) {\n            this.rightChild == node;\n        } else {\n            this.rightChild.insert(node);\n        }\n    } else {\n        return; // key is alr in the tree!\n    }\n}\n</code></pre></p> <p>Successor: Here is where it gets complicated. This can be broken down into several cases. \\(O(height)\\). - Case 1: Node has a right child \\(\\Rightarrow\\) Successor is the smallest element in the right subtree - Case 2: Node has no right child \\(\\Rightarrow\\) Successor is the first parent that is bigger than node <pre><code>public TreeNode successor() {\n    if (this.rightChild != null) {\n        return this.rightChild.getMin();\n    }\n\n    TreeNode parent = this.parentTree;\n    TreeNode child = this;\n\n    while ((parent != null) and (child == parent.rightTree)) {\n        child = parent;\n        parent = child.parentTree;\n    }\n\n    return parent;  \n}\n</code></pre></p> <p>Delete: Remove a node! (not easy) - Case 1: No children \\(\\Rightarrow\\) easy! just remove it! - Case 2: 1 child \\(\\Rightarrow\\) Also easy! Reroute the parents edge to the child of the node! - Case 3: 2 children \\(\\Rightarrow\\) Not so simple.      - Claim: Successor of a deleted node has at most 1 child!     - Proof: Deleted node has two children. Hence, it has a rightChild. From Successor query, we can show that the successor of the deleted node will be the minimum of that subtree and will not have any children! We can replace the two nodes and safely delete!</p>"},{"location":"CS2040S/Binary%20Search%20Trees%20%28BST%29/#tree-shapes","title":"Tree Shapes","text":"<p>What determines the shape? Order of insertion of keys How many possible shapes are there? Look up Catalan Numbers Performance depends on insertion. Insert keys in random order \\(\\Rightarrow\\) balanced!</p>"},{"location":"CS2040S/Binary%20Search%20Trees%20%28BST%29/#problems","title":"Problems","text":"<p>Imagine we add the following array into a BST in sequential order <code>[1, 2, 3, 4, 5]</code> This will cause the BST to degenerate into a Linked List! Our \\(O(log(n))\\) runtime would degenerate into \\(O(n)\\). This is why it is important for our tree to be balanced.</p> <p>Balanced Trees</p>"},{"location":"CS2040S/Binary%20Trees/","title":"Binary Trees","text":"<p>CS2040S Home Page | Data Structures | Trees</p>"},{"location":"CS2040S/Binary%20Trees/#definition","title":"Definition:","text":"<p>A Binary Tree is: (a) empty, or (b) a node pointing to two binary trees.</p>"},{"location":"CS2040S/Binary%20Trees/#java-pseudocode","title":"Java Pseudocode","text":"<pre><code>public class TreeNode {\n    private TreeNode leftNode;\n    private TreeNode rightNode;\n\n    private Key key;\n    private Value value;\n\n    // Constructor and methods omitted for brevity\n}\n</code></pre>"},{"location":"CS2040S/Binary%20Trees/#terminology-and-operations","title":"Terminology and Operations","text":"<p>Height: Number of edges on the longest path from root to leaf <pre><code>h(v) == 0; // v is a leaf!\nh(v) = max(h(v.leftChild), h(v.rightChild)) + 1;\nh(null) = -1; // convention and simplicity\n</code></pre></p> <p>Calculate Height: <pre><code>public int height(TreeNode node) {\n    if (node == null) {\n        return -1;\n    }\n\n    int leftHeight = height(node.leftChild);\n    int rightHeight = height(node.rightChild);\n\n    return max(h(v.leftChild), h(v.rightChild)) + 1;\n}\n</code></pre></p> <p>Level: Number of edges from root node</p>"},{"location":"CS2040S/Binary%20Trees/#tree-traversal-on","title":"Tree Traversal \\(O(n)\\)","text":""},{"location":"CS2040S/Binary%20Trees/#in-order-traversal","title":"In-order Traversal","text":"<pre><code>public String inOrderTraversal() {\n    if (this == null) {\n        return;\n    }\n\n    String traversal = this.leftChild.inOrderTraversal() + ((String) this.value) + \" \" + this.rightChild.inOrderTraversal();\n\n    return traversal;   \n}\n</code></pre>"},{"location":"CS2040S/Binary%20Trees/#pre-order-traversal","title":"Pre-order Traversal","text":"<pre><code>public String preOrderTraversal() {\n    if (this == null) {\n        return;\n    }\n\n    String traversal = ((String) this.value) + \" \" + this.leftChild.preOrderTraversal() + this.rightChild.preOrderTraversal();\n\n    return traversal;   \n}\n</code></pre>"},{"location":"CS2040S/Binary%20Trees/#post-order-traversal","title":"Post-order Traversal","text":"<pre><code>public String postOrderTraversal() {\n    if (this == null) {\n        return;\n    }\n\n    String traversal = this.leftChild.postOrderTraversal() + this.rightChild.postOrderTraversal() + ((String) this.value) + \" \";\n\n    return traversal;   \n}\n</code></pre>"},{"location":"CS2040S/Binary%20Trees/#level-order-traversal","title":"Level-order Traversal","text":"<p>[TODO]</p>"},{"location":"CS2040S/Binary%20Trees/#variation","title":"Variation","text":"<ul> <li>Binary Search Trees (BST)</li> </ul>"},{"location":"CS2040S/Bubble%20Sort/","title":"Bubble Sort","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Bubble%20Sort/#java-pseudocode","title":"Java Pseudocode","text":"<pre><code>BubbleSort(A, n) {\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; i &lt; n - 1; i++) {\n            if (A[j] &gt; A[j + 1]) {\n                swap(A[j], A[j + 1]); // Assume swap exists\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"CS2040S/Bubble%20Sort/#invariant","title":"Invariant","text":"<ul> <li>After i-iterations, the last i items will be sorted and the largest i elements in <code>A</code>.</li> </ul>"},{"location":"CS2040S/CS2040S%20Home%20Page/","title":"CS2040S Home Page","text":"<ol> <li>Introduction to DSA</li> <li>Data Structures</li> <li>Algorithmic Analysis</li> <li>Searching</li> <li>Peak Finding</li> <li>Sorting</li> <li>Trees</li> <li>Hashing</li> <li>Graphs</li> <li>Topological Sorting</li> <li>Single-Source Shortest Paths</li> <li>Minimum Spanning Trees</li> <li>Special Topics</li> </ol> <p>Additional Resources: 1. Common Recurrence Relations 2. </p> <p>Notes by Dhruv Sharma</p>"},{"location":"CS2040S/Choosing%20a%20pivot/","title":"Choosing a pivot","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Choosing%20a%20pivot/#good-pivot","title":"\"Good Pivot\"","text":"<p>A deterministic pivot can always have an adversarial input engineered. The Deterministic QuickSort Recurrence will look like \\(T(n) = T(n - 1) + T(1) + n\\) --&gt; \\(O(n^2)\\). We want to find a pivot that roughly splits the array into two equivalent (or good enough parts). As such, we must turn to probability. </p>"},{"location":"CS2040S/Choosing%20a%20pivot/#probably-good","title":"\"Probably Good\"","text":"<p>Lets arbitrarily say that a pivot is good if it can split an array into \\(9 : 1\\). If we pick a pivot at random, the probability that the pivot is bad is \\(\\frac{2}{10}\\). Likewise a good pivot's probability is \\(\\frac{8}{10}\\).</p> <p>Assuming that we use the paranoid implementation of Quick Sort, we can calculate the expected value of the recurrence. The expected value can be calculated. Note: \\(X\\) is the number of iterations of choosing the pivot by being paranoid.  $$ E[X] = \\frac{8}{10} * 1 + (1 -\\frac{8}{10}) * (E[X] + 1)  $$$$ E[X] = \\frac{8}{10} +  E[X] - \\frac{8}{10}*E[X] + 1 - \\frac{8}{10} $$ $$ \\frac{8}{10} * E[X] = 1  $$ $$  E[X] = \\frac{10}{8} $$</p> <p>Hence, the expected number of iterations needed is \\(\\frac{10}{8}\\), or about \\(2\\). From this, we can construct a recurrence relation \\(T(n) \\leq T(\\frac{n}{10}) + T(\\frac{9n}{10}) + E[\\#pivot](n) \\equiv T(\\frac{n}{10}) + T(\\frac{9n}{10}) + 2n = O(nlog(n))\\). Hallelujah. Hence, Paranoid Quick Sort has an expected runtime of \\(O(nlog(n))\\).  </p>"},{"location":"CS2040S/Common%20Recurrence%20Relations/","title":"Common Recurrence Relations","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Common%20Recurrence%20Relations/#recurrence-relations","title":"Recurrence Relations","text":"<p>Note: a, b, d and k are all constant values 1. \\(T(n) = T(n-1)+b, T(1) = a\\) \\(T(n) = O(n)\\) 2. \\(T(n) = T(n-1) + bn, T(1) = a\\) \\(T(n) = O(n\u00b2)\\) 3. \\(T(n) = T(n/2) + b, T(1) = a\\) \\(T(n) = O( log n)\\) 4. \\(T(n) = T(n/2) + bn, T(1) = a\\) \\(T(n) = O(n)\\) 5. \\(T(n) = kT(n/k) + b, T(1) = a\\) \\(T(n) = O(n)\\) 6. \\(T(n) = kT(n/k) + bn, T(1) = a\\) \\(T(n) = O(n log n)\\) 7. \\(T(n) = T(n-1) + T(n-2) + d, T(1) = a, T(2) = b\\) \\(T(n) = O(2^n)\\) 8. \\(T(n) = 2T(n - 1) + d, T(1) = a\\) \\(T(n) = O(2^n)\\) 9. \\(T(n) = T(n-1) + b n^k, T(1) = a\\) \\(T(n) = O(n^{(k+1)})\\)</p>"},{"location":"CS2040S/Data%20Structures/","title":"Data Structures","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Data%20Structures/#types-of-data-structures","title":"Types of Data Structures:","text":"<ul> <li>Arrays </li> <li>Linked Lists</li> <li>Queues</li> <li>Stacks</li> <li>Trees</li> <li>Binary Trees</li> <li>Balanced Trees</li> <li>[[Interval Trees]]</li> <li>[[(a,b)-Trees]]</li> <li>[[kd-Trees]]</li> <li>[[Hash Maps]]</li> </ul>"},{"location":"CS2040S/Find%20Peak/","title":"Find Peak","text":"<p>CS2040S Home Page | Peak Finding | 1-dimension Peak Finding</p>"},{"location":"CS2040S/Find%20Peak/#linear-sort-implementation","title":"Linear sort implementation","text":"<p>FindPeak:     Start from <code>A[1]</code>      Examine every element      Stop when you find a peak</p> <p>Runs in O(n)</p>"},{"location":"CS2040S/Find%20Peak/#binary-search-implementation","title":"Binary Search Implementation:","text":"<p>FindPeak:  <pre><code>FindPeak(A, n):\n    if A[n / 2 + 1] &gt; A[n / 2] then\n        FindPeak(A[n / 2 + 1, ..., n], n / 2)\n    if A[n / 2 - 1] &gt; A[n / 2] then\n        FindPeak(A[1, ..., n / 2 - 1], n / 2)\n    else A[n / 2] is a peak, return n / 2\n</code></pre></p>"},{"location":"CS2040S/Find%20Peak/#why-does-this-work","title":"Why does this work?","text":"<p>Key Property: Invariant     If we recurse on the right, there is a peak on the right.</p> <p>Explanation: <pre><code>\u2013 Assume there is \u201cno peak\u201d in the right half.\n\u2013 Given: A[middle] &lt; A[middle + 1]\n\u2013 Since no peaks, A[middle+1] &lt; A[middle+2]\n\u2013 Since no peaks, A[middle+2] &lt; A[middle+3]\n\u2013 . . .\n\u2013 Since no peaks, A[n-1] &lt; A[n] //PEAK!! \n</code></pre></p>"},{"location":"CS2040S/Find%20Peak/#convince-yourself-this-works","title":"Convince yourself this works!","text":"<p>Invariant: Correctness 1. \\(\\exists peak[begin, end]\\) (This is not enough to prove that the peak is in this range!) 2. Every peak in \\([begin, end]\\) is a peak in \\([1, n]\\)</p> <p>The recursion relation for the binary implementation would be  \\(T(n) = T(n/2) + O(1)\\) which would evaluate to  \\(O(log(n))\\)</p> <p>Note: Common Recurrence Relations</p>"},{"location":"CS2040S/Graphs/","title":"Graphs","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Hash%20Table/","title":"Hash Table","text":"<p>CS2040S Home Page</p> <p>Operations: - Insert(key, value)     - calc h(key)      - add to table - search(key)     - </p>"},{"location":"CS2040S/Hashing/","title":"Hashing","text":"<p>CS2040S Home Page</p> <p>TODO: Watch Lecture 12</p> <p>Topics Direct Access Tables: - Problem:      - Huge number of possible keys, not necessary that all the keys will go inside universe U</p> <p>Solution: Hashing - function that limits universe U size Problems: Collision  two distinct keys may collide if they are hashed to the same address</p> <p>Solution to Collision: Chaining </p> <p>Hash Table</p> <p>Assumption: SUHA - Assume      - n items     - m buckets - Define load(hash table) = n/m</p> <p>Searching  - expected O(1) + n/m = O(1) with SUHA</p> <p>expected maximum chain length with SUHA is O(log(n))</p> <p>See: Power of Two Choices Java Map </p>"},{"location":"CS2040S/Insertion%20Sort/","title":"Insertion Sort","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Insertion%20Sort/#java-pseudocode","title":"Java Pseudocode","text":"<pre><code>InsertionSort(A, n) {\n    for (int i = 0; i &lt; n - 1; i++) {\n        key = A[i];\n        j = i - 1;\n\n        while (j &gt;= 0 and A[j] &gt; key) {\n            A[j + 1] = A[j];\n            j = j - 1;\n        }\n\n        A[j + 1] = key;\n    }\n}\n</code></pre>"},{"location":"CS2040S/Insertion%20Sort/#invariants","title":"Invariants","text":"<p>At the end of i-iterations, the first i-items are in sorted order</p>"},{"location":"CS2040S/Introduction%20to%20DSA/","title":"Introduction to DSA","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Introduction%20to%20DSA/#motivation","title":"Motivation","text":"<p>If you need your software to run twice as fast, hire a better programmer If you need your software to run more than twice as fast, use a better algorithm</p> <p>This course will give you an insight into the world of analysis, algorithms and data structures that make use of them. Even though its hard as hell, we can have some fun while doing it!</p>"},{"location":"CS2040S/Introduction%20to%20DSA/#additional-resources","title":"Additional Resources","text":"<p>[[CS2040S Resources]]</p>"},{"location":"CS2040S/Merge%20Sort/","title":"Merge Sort","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Merge%20Sort/#divide-and-conquer-sort","title":"Divide and Conquer Sort","text":"<p>Step 1: Divide - Split the array into two halves Step 2: Recurse - Sort the two halves Step 3: Combine - Merge the sorted halves</p>"},{"location":"CS2040S/Merge%20Sort/#java-pseudocode","title":"Java Pseudocode","text":"<p>Lecture implementation: (Not in place!)</p> <pre><code>Merge(A1, A2) {\n    l = A1.length;\n    m = A2.length;\n\n    res = new Array[l + m]\n    i, j, k = 0;\n\n    while (i &lt; l and j &lt; m) {\n        if (A1[i] &lt;= A2[j]) {\n            res[k++] = A1[i++];\n        } else {\n            res[k++] = A2[j++];\n        }\n    }\n\n    while (i &lt; l) {\n        res[k++] = A1[i++];\n    }\n\n    while (j &lt; m) {\n        res[k++] = A1[j++];\n    }\n\n    return res;\n}\n\nMergeSort(A, n) {\n    if (n == 1) {\n        return; // an array of 1 is always sorted\n    }\n\n    A = MergeSort(A[1, ..., n / 2], n / 2);\n    B = MergeSort(A[n / 2 + 1, ..., n], n / 2);\n\n    return Merge(A, B);\n}\n</code></pre> <p>In-place implementation: <pre><code>Merge(A, B, begin, mid, end) {\n    i, k = 0;\n    j = mid;\n\n    while (i &lt; mid and j &lt; end) {\n        if (B[i] &lt;= B[j]) {\n            A[k++] = B[i++];\n        } else {\n            A[k++] = B[j++];\n        }\n    }\n\n    while (i &lt; mid) {\n        A[k++] = B[i++];\n    }\n    while (j &lt; end) {\n        A[k++] = B[i++];\n    }\n    return A;\n}\n\nMergeSort(A, B, begin, end) {\n    if (begin == end) {\n        return;\n    }\n\n    n = end - begin;\n    MergeSort(B, A, 0, n / 2);\n    MergeSort(B, A, n / 2 + 1, end);\n    Merge(A, 0, n / 2, end);\n    return A;   \n}\n</code></pre></p>"},{"location":"CS2040S/Merge%20Sort/#invariants","title":"Invariants","text":"<p>With every recursive call, the problem size is split into halves until it converges to n = 1, where by virtue of it being the only value will always be sorted. </p>"},{"location":"CS2040S/Minimum%20Spanning%20Trees/","title":"Minimum Spanning Trees","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Optimisations%20for%20Quick%20Sort/","title":"Optimisations for Quick Sort","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Optimisations%20for%20Quick%20Sort/#many-optimisations-are-available","title":"Many Optimisations are available!","text":""},{"location":"CS2040S/Optimisations%20for%20Quick%20Sort/#base-case","title":"Base case?","text":""},{"location":"CS2040S/Optimisations%20for%20Quick%20Sort/#option-1","title":"Option 1:","text":"<ul> <li>Recurse all the way down</li> </ul>"},{"location":"CS2040S/Optimisations%20for%20Quick%20Sort/#option-2","title":"Option 2:","text":"<ul> <li>Switch to Insertion Sort for small arrays! </li> </ul>"},{"location":"CS2040S/Optimisations%20for%20Quick%20Sort/#option-3","title":"Option 3:","text":"<ul> <li>Halt recursion early so that there are many small subarrays that are unsorted and switch to Insertion Sort (Since it works great for almost sorted arrays!) </li> </ul>"},{"location":"CS2040S/Peak%20Finding/","title":"Peak Finding","text":"<p>CS2040S Home Page</p> <p>Relevant Links: Searching, Algorithmic Analysis</p>"},{"location":"CS2040S/Peak%20Finding/#motivation","title":"Motivation","text":"<p> An algorithm that is able to find global and local maxima</p>"},{"location":"CS2040S/Peak%20Finding/#global-maximum-for-optimization-problems","title":"Global Maximum for Optimization problems:","text":"<ul> <li>Finds a good solution for a problem</li> <li>Way to save costs, save time or make more money Input: <code>A[0, 1, ..., n - 1]</code> Output: max element in <code>A</code>.</li> </ul>"},{"location":"CS2040S/Peak%20Finding/#local-maximum-for-optimization-problems","title":"Local Maximum for Optimization problems:","text":"<ul> <li>Finds a \"good enough\" solution for a problem</li> <li>Not necessarily the best solution  Input: <code>A[0, 1, ..., n - 1]</code> Output: a local maximum in A <code>A[i - 1] &lt;= A[i]</code> and <code>A[i + 1] &lt;= A[i]</code> Assume that <code>A[-1] = A[n] = Integer.MIN_VALUE</code></li> </ul>"},{"location":"CS2040S/Peak%20Finding/#1-dimension","title":"1-dimension","text":"<p>1-dimension Peak Finding</p>"},{"location":"CS2040S/Peak%20Finding/#2-dimension","title":"2-dimension","text":"<p>2-dimension Peak Finding</p>"},{"location":"CS2040S/Peak%20Finding/#summary","title":"Summary","text":"<ul> <li>Divide and Conquer (Binary Search) in \\(O(log(n))\\) time</li> <li>Simple Divide and Conquer 2D with Binary Search in \\(O(nlog(m))\\) time</li> <li>Careful Divide and Conquer in \\(O(n)\\) time</li> </ul>"},{"location":"CS2040S/Quick%20Select/","title":"Quick Select","text":"<p>CS2040S Home Page | Sorting | Quick Sort 3-way partition</p> <pre><code>QuickSelect(A, k, begin, end) {\n    if (end - begin == 0) {\n     return A[beign];\n    } else {\n        int [] p = threeWayPart(A, begin, end);\n        if (k &gt; p[0] and k &lt; p[1]) {\n            return A[k];\n        } else if (k &lt;= p[0]) {\n            return QuickSelect(A, k, begin, p[0]);\n        } else {\n            return Quickselect(A, k, p[1], end);\n        }\n    }\n}\n</code></pre> <p>Note for the above implementation, this would be single pass Quick Select which is slightly different from the slides. </p>"},{"location":"CS2040S/Quick%20Sort%203-way%20partition/","title":"Quick Sort 3 way partition","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Quick%20Sort%203-way%20partition/#java-pseudocode","title":"Java Pseudocode","text":"<pre><code>QuickSort(A, begin, end) {\n    if (begin &gt;= end) {\n        return;\n    } else {\n        int[] p = threeWayPart(A, begin, end);\n        x = QuickSort(A, begin, p[0]);\n        y = QuickSort(A, p[1], end);\n    }\n}\n\n// with duplicates\nthreeWayPart(A, begin, end) {\n    if (A.length &gt; 1) {\n        pivotIdx = random(begin, end); //probabilistic pivot choice\n        int pivot = A[pivotIdx];\n        swap(A[begin], A[pivotIdx]);\n\n        eqBegin = begin;\n        eqEnd = begin;\n        ipBegin = start + 1;\n        ipEnd = end;\n\n        while (ipBegin &lt;= ipEnd) {\n            int curr = arr[ipStart];\n            // less than pivot\n            if (curr &lt; pivot) {\n                swap(A[ipStart], A[eqStart]);\n                // increment pointers\n                eqStart++;\n                eqEnd++;\n                ipStart++;\n            // equal to pivot\n            } else if (curr == pivot) {\n                swap(A[ipStart], A[eqEnd]);\n                // increment pointers\n                eqEnd++;\n                ipStart++;      \n            // more than pivot  \n            } else {\n                swap(A[ipStart], A[ipEnd]);\n                ipEnd--;\n            }\n        }\n        // return the boundaries\n        int[] result = {eqStart - 1, eqEnd + 1};\n        return result;\n    } else {\n        return null;\n    }\n}\n</code></pre>"},{"location":"CS2040S/Quick%20Sort%203-way%20partition/#three-pass-partition","title":"Three-Pass Partition","text":""},{"location":"CS2040S/Quick%20Sort%203-way%20partition/#option-1-2-pass-partition","title":"Option 1: 2 pass partition","text":"<p>Step 1: Regular partition Step 2: Pack duplicates</p>"},{"location":"CS2040S/Quick%20Sort%203-way%20partition/#option-2-1-pass-partition","title":"Option 2: 1 pass partition","text":"<p>Maintain 4 regions of the array  </p>"},{"location":"CS2040S/Quick%20Sort%203-way%20partition/#invariant","title":"Invariant:","text":"<p>The pivot and any element numerically equal to the pivot will be in the correct positions in the array. Elements to their left are &lt; them and elements to their right are &gt; than them.</p>"},{"location":"CS2040S/Quick%20Sort/","title":"Quick Sort","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Quick%20Sort/#java-pseudocode","title":"Java Pseudocode","text":"<pre><code>QuickSort(A, begin, end) {\n    if (n == 1) {\n        return;\n    } else {\n        total = end - begin\n        p = partition(A, begin, end);\n        x = QuickSort(A, begin, p - 1);\n        y = QuickSort(A, p + 1, end);\n    }\n}\n\n// assuming no duplicates\npartition(A, begin, end) {\n    // pivot = random(begin to end); probabilitstic approach, good expected val\n    pivot = begin // deterministic approach, adversary can impede\n    left = begin + 1;\n    right = end;\n\n    while (left &lt; right) {\n        while (A[left] &lt; pivot and left &lt; right) { left++; }\n        while (A[right] &gt; pivot and left &lt; right) { right--; }\n        if (A[left] &lt; A[right]) swap(A[left], A[right]);\n    }\n    // final swap to put pivot in correct spot\n    swap(A[0], A[left - 1]); // assuming pivot is the first element\n    // return pivot index\n    return low - 1;\n}\n</code></pre>"},{"location":"CS2040S/Quick%20Sort/#invariants","title":"Invariants","text":"<p>Single partition: - <code>A[right] &gt; pivot</code> at the end of every loop -- true by assumption <code>A[n + 1] = Interger.MAX_VALUE</code>  - <code>A[right] &gt; pivot</code> at the end of every iteration      - During loop:          - When exiting <code>while (A[left] &lt; pivot and left &lt; right)</code>: <code>A[left] &gt; pivot</code>             - if <code>(left &gt; right)</code>, then by <code>while</code> condition             - if <code>(left == right)</code>, then by inductive assumption         - When exiting <code>while (A[right] &gt; pivot and left &lt; right)</code>:  <code>A[right] &lt; pivot</code> OR <code>right == left</code>             - if <code>(right == left)</code>, then <code>A[high] &gt; pivot</code>             - else <code>swap(A[high], A[low])</code> &gt; <code>pivot</code> - At the end of every loop iteration:     - for all <code>i &gt;= right</code>, <code>A[i] &gt; pivot</code>      - for all <code>j &gt; 1 and j &lt; left</code>, <code>A[j] &lt; pivot</code> </p> <p></p>"},{"location":"CS2040S/Searching/","title":"Searching","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Searching/#computerscience-dsa-algorithms","title":"ComputerScience #DSA #Algorithms","text":""},{"location":"CS2040S/Searching/#linear-search","title":"Linear Search","text":""},{"location":"CS2040S/Searching/#goal","title":"Goal","text":"<p>Find an element in an array</p> <p>Just look through every element in the array. Slow and inefficient :(. But sometimes still necessary, and computationally more suited than binary search! (esp if your search space is not sorted~).</p>"},{"location":"CS2040S/Searching/#binary-search","title":"Binary Search","text":""},{"location":"CS2040S/Searching/#goal_1","title":"Goal","text":"<p>Find an element in a sorted array</p>"},{"location":"CS2040S/Searching/#precondition","title":"Precondition","text":"<p>Sorted array in ascending order (Do not do input validation as that would slow down the algorithm!) Array is of size n</p>"},{"location":"CS2040S/Searching/#postcondition","title":"Postcondition","text":"<p>If element is in the array, <code>A[begin] == key</code></p>"},{"location":"CS2040S/Searching/#invariant","title":"Invariant","text":"<p>The key is always within the range of the array</p> <p>Correctness: <code>A[begin] &lt;= key &lt;= A[end]</code></p> <p>Performance: <code>(end - begin) &lt;= n/(2^k)</code> in iteration k</p>"},{"location":"CS2040S/Searching/#implementation","title":"Implementation","text":"<pre><code>int search(int[] A, int key, int n) {\n    int begin = 0;\n    int end = n - 1;\n    while (begin &lt; end) { \n        mid = begin + (end - begin) / 2;\n        if (key &lt;= A[mid]) {\n            end = mid;\n        } else {\n            begin = mid + 1;\n        }\n    }\n    return (A[begin] == key) ? begin : -1;\n}\n</code></pre>"},{"location":"CS2040S/Searching/#binary-search-to-find-max-students","title":"Binary Search to find max students","text":"<pre><code>int search(int[] A, int key, int n) {\n    int begin = 0;\n    int end = n - 1;\n    while (begin &lt; end) { \n        mid = begin + (end - begin) / 2;\n        if (MaxStudents(mid) &lt;= 18) { // This is the only line that changed!\n            end = mid;\n        } else {\n            begin = mid + 1;\n        }\n    }\n    return (A[begin] == key) ? begin : -1;\n}\n</code></pre>"},{"location":"CS2040S/Searching/#time-and-space-complexity","title":"Time and Space Complexity:","text":"<p>Time and Space Complexity Mega Table</p>"},{"location":"CS2040S/Searching/#peak-finding","title":"Peak-Finding","text":"<p>How search algorithms can be used: Peak Finding</p>"},{"location":"CS2040S/Selection%20Sort/","title":"Selection Sort","text":"<p>CS2040S Home Page | Sorting</p>"},{"location":"CS2040S/Selection%20Sort/#java-pseudocode","title":"Java Pseudocode","text":"<pre><code>SelectionSort(A, n) {\n    for (int i = 0; i &lt; n; i++) {\n        minIndex = i\n        for (int j = i; j &lt; n; j++) { //finding the min element\n            minIndex = (A[minIndex] &lt;= A[j]) ? minIndex : j;\n        }\n        swap(A[i], A[minIndex]);\n    }\n}\n</code></pre>"},{"location":"CS2040S/Selection%20Sort/#invariant","title":"Invariant","text":"<p>After i-iterations, the first i-elements will be sorted and the smallest i elements in <code>A</code>.</p>"},{"location":"CS2040S/Single-Source%20Shortest%20Paths/","title":"Single Source Shortest Paths","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Sorting/","title":"Sorting","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Sorting/#key-questions","title":"Key Questions","text":"<ul> <li>How to analyse a sorting algorithm?</li> <li>What are the invariants?</li> <li>What are the trade-offs? When to use which implementation?</li> </ul>"},{"location":"CS2040S/Sorting/#properties-of-sorting-algorithms","title":"Properties of Sorting Algorithms","text":"<ul> <li>Runtime<ul> <li>How many operations to sort the space?</li> </ul> </li> <li>Space Usage<ul> <li>How much additional memory required?</li> </ul> </li> <li>Stability<ul> <li>Does sorting preserve the initial order of the elements in the space?</li> </ul> </li> </ul>"},{"location":"CS2040S/Sorting/#sorting-algorithms","title":"Sorting Algorithms","text":""},{"location":"CS2040S/Sorting/#bogosort-joke-sort","title":"BogoSort (Joke Sort)","text":"<p>Step 1: Choose a random permutation of the Array A Step 2: If the permutation is sorted, DONE, else repeat</p> <p>Runtime: \\(O(n*n!)\\) Space Complexity: \\(O(1)\\)</p>"},{"location":"CS2040S/Sorting/#bubble-sort-stable","title":"Bubble Sort (Stable)","text":"<p>Bubble Sort</p>"},{"location":"CS2040S/Sorting/#selection-sort-unstable","title":"Selection Sort (Unstable)","text":"<p>Selection Sort</p>"},{"location":"CS2040S/Sorting/#insertion-sort-stable","title":"Insertion Sort (Stable)","text":"<p>Insertion Sort</p>"},{"location":"CS2040S/Sorting/#merge-sort-stable","title":"Merge Sort (Stable)","text":"<p>Merge Sort</p>"},{"location":"CS2040S/Sorting/#quick-sort-unstable","title":"Quick Sort (Unstable)","text":"<p>Quick Sort Quick Sort 3-way partition Choosing a pivot Optimisations for Quick Sort</p>"},{"location":"CS2040S/Sorting/#order-statistics","title":"Order Statistics","text":"<p>Problem: Finding the k-th smallest element in an array <code>A</code>. </p> <p>Option 1: Sort the array and return <code>A[k - 1]</code>. - Expected Time: \\(O(nlog(n))\\) Option 2: Quick Select</p>"},{"location":"CS2040S/Sorting/#runtimes","title":"Runtimes","text":"<p>Time and Space Complexity Mega Table</p>"},{"location":"CS2040S/Special%20Topics/","title":"Special Topics","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Steep%20Peaks/","title":"Steep Peaks","text":"<p>CS2040S Home Page | Peak Finding | 1-dimension Peak Finding</p> <p>Input: <code>A[0, 1, ..., n - 1]</code> Output: a local maximum in A <code>A[i - 1] &lt; A[i]</code> and <code>A[i + 1] &lt; A[i]</code> &lt;-- Note that the equality has changed from FindPeak! Assume that <code>A[-1] = A[n] = Integer.MIN_VALUE</code></p> <p>HOWEVER! The Find Peak approach cannot be used here!</p> <p> We can't say! Is there a missing else condition to our FindPeak implementation? What if we recurse on both sides?</p> <p>FindPeak:  <pre><code>FindPeak(A, n):\n    if A[n / 2 + 1] &gt; A[n / 2] then\n        FindPeak(A[n / 2 + 1, ..., n], n / 2)\n    if A[n / 2 - 1] &gt; A[n / 2] then\n        FindPeak(A[1, ..., n / 2 - 1], n / 2)\n    if A[n / 2 - 1] == A[n / 2] == A[n / 2 + 1] then\n        FindPeak(A[1, ..., n / 2 - 1]) and FindPeak(A[n / 2 + 1, ..., n])\n    else A[n / 2] is a steep peak, return n / 2\n</code></pre></p> <p>What is the recurrence? \\(T(n) = 2T(n/2) + O(1)\\) \\(= O(n)\\)</p>"},{"location":"CS2040S/Time%20and%20Space%20Complexity%20Mega%20Table/","title":"ComputerScience #Algorithms #DSA","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Time%20and%20Space%20Complexity%20Mega%20Table/#mega-tables","title":"Mega Tables","text":"Algorithm Best (Time) Average (Time) Worst (Time) Best (Space) Average (Space) Worst (Space) Linear Search n n n n n n Binary Search log n log n log n n n n Bubble Sort n n^2 n^2 1 1 1 Selection Sort n^2 n^2 n^2 1 1 1 Insertion Sort n n^2 n^2 1 1 1 Merge Sort n log n n log n n log n Quick Sort n log n n log n n^2"},{"location":"CS2040S/Topological%20Sorting/","title":"Topological Sorting","text":"<p>CS2040S Home Page</p>"},{"location":"CS2040S/Trees/","title":"Trees","text":"<p>CS2040S Home Page | Data Structures</p>"},{"location":"CS2040S/Trees/#motivation","title":"Motivation","text":"<p>I want to implement a dictionary (collection of key-value pairs) that supports the following operations:</p> <pre><code>void insert(Key k, Value v) {} // add key-value pair\nValue search(Key k) {} // find k\nKey successor(Key k) {} // find next key &gt; k\nKey predeccessor(Key k) {} // find next key &lt; k\nvoid delete(Key k) {} // remove k and its value\nboolean contains(Key k) {} // is there a value for k?\nint size() //number of key-value pairs\n</code></pre> <p>There are many ways to approach this...</p>"},{"location":"CS2040S/Trees/#approach-1-unsorted-array","title":"Approach 1: Unsorted Array","text":"<ul> <li>insert: \\(O(1)\\)</li> <li>search: \\(O(n)\\)</li> </ul>"},{"location":"CS2040S/Trees/#approach-2-sorted-array","title":"Approach 2: Sorted Array","text":"<ul> <li>insert: \\(O(n)\\)</li> <li>search: \\(O(log(n))\\)</li> </ul>"},{"location":"CS2040S/Trees/#approach-3-linked-list","title":"Approach 3: Linked List","text":"<ul> <li>insert: \\(O(1)\\)</li> <li>search: \\(O(n)\\)</li> </ul> <p>Which implementation is best? What are the trade-offs? What are the benefits? There is no strict best answer, but we can add another tool (Trees!) to your toolbox!</p>"},{"location":"CS2040S/Trees/#terminology","title":"Terminology","text":"<p>Nodes: Key-value pair in a list. Contains the data Edges: Path from one node to another Root: Special node, does not have any parents Leaves: Special node, does not have any children Siblings: Special nodes, shares the same parents</p> <p>There are no cycles in a tree!</p>"},{"location":"CS2040S/Trees/#variations","title":"Variations","text":"<ul> <li>Binary Trees</li> <li>Binary Search Trees (BST)</li> </ul>"},{"location":"IS1108/Artificial%20Intelligence%20Ethics%20and%20Governance/","title":"Artificial Intelligence Ethics and Governance","text":"<p>IS1108 Home Page</p>"},{"location":"IS1108/Artificial%20Intelligence%20Ethics%20and%20Governance/#what-is-ai","title":"What is AI","text":"<p>Branch of computer science dedicated to the creation of intelligent machines that can do work and react like humans. As such, we as professionals should have ethics to guide us to prevent misuse of such powerful tools.</p> <p>There are different kinds of AI:  <pre><code>graph TD;\n    A[AI]--&gt;B{Reacitve};\n    A--&gt;C{Limited Memory };\n    A--&gt;D{Theory Of Mind};\n    A--&gt;E{Self-Aware};</code></pre></p> <p>There are three main ethical concerns regarding the use of AI:  1. Privacy 2. Bias and Discrimination 3. Human Judgement</p> <p>To minimise these concerns, we must develop AI systems with the following pillars as a foundation:</p> <p></p> <p>All of these concepts can be summarised in two guiding principles: </p> <p>Decisions made by AI systems must be \"explainable, transparent and fair\"</p> <p>We should not deploy AI systems whose inner workings we are unable to fully understand as it will lead to unpredictable outcomes.</p> <p>AI systems should be human-centric</p> <p>The implementation of AI systems must not cause harm to humans, either directly or as a by-product (loss of employment). There should be a way to help those that are affected.</p>"},{"location":"IS1108/Artificial%20Intelligence%20Ethics%20and%20Governance/#ai-governance","title":"AI Governance","text":"<p>Governance is the idea that there should be legal frameworks that ensure AI and machine learning technologies are well researched and developed with the goal of helping humanity navigate the adoption of AI systems fairly. </p>"},{"location":"IS1108/Artificial%20Intelligence%20Ethics%20and%20Governance/#body-of-knowledge-bok","title":"Body of Knowledge (BoK)","text":"<p>Provides guidance to business leaders and professionals on how to deploy AI responsibly. </p>"},{"location":"IS1108/Artificial%20Intelligence%20Ethics%20and%20Governance/#guiding-principles-in-practice","title":"Guiding principles in practice","text":"<p>The following four concepts can be used as metrics for AI Governance: 1. Internal governance: Incorporate values, risks and responsibilities relating to algorithmic decision making 2. Operations management 3. Human-centricity: Determine level of human involvement in AI decision making 4. Stakeholder Communications</p>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/","title":"Automation and Autonomous Systems","text":"<p>IS1108 Home Page</p>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/#goal-of-automated-systems","title":"Goal of Automated Systems","text":"<p>Automation is the ability of a system to perform well-defined tasks to produce deterministic results. This is done by closely following a set of rules and algorithms without the reliance of AI technologies.</p> <pre><code>graph LR\n    A(Input) --&gt; B(Desired Outcome);\n    B --&gt; C(Automated System);\n    C --&gt; D(Actual Outcome);\n    D --&gt; E(Output);</code></pre> <p>Example: Washing Machine, Vending Machine, Inventory Logger, etc</p>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/#goal-of-autonomous-systems","title":"Goal of Autonomous Systems","text":"<p>Autonomous Systems are the next step in the evolution of automation. Here AI is applied to the system.</p> <pre><code>graph TD\n    A(Input) --&gt; B(Desired Outcome);\n    B --&gt; C(Autonomous System);\n    C --&gt; V{Desired Goal?};\n    V --&gt; |Yes| D(Actual Outcome);\n    V --&gt; |Not Yet| C;\n    D --&gt; E(Output);</code></pre> <p>Example: Self-Driving Car, Drones, Anti-Missile System, etc</p>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/#key-challenges-in-autonomous-systems","title":"Key Challenges in Autonomous Systems","text":"<ul> <li>Principle of Double Effect - from topic 1</li> <li>Autonomous Driving</li> <li>Autonomous Care-giving </li> </ul>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/#impact","title":"Impact","text":"<ul> <li>Low Impact is when the environment is constrained. An autonomous train is low impact as it is confined to its train tracks vs a self-driving car which can go onto all roads and is therefore high impact. It can also be said to be the degree by which it can affect human life.</li> </ul>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/#autonomy","title":"Autonomy","text":"<ul> <li>Low autonomy is when there is high human involvement, and high autonomy would be the opposite.</li> </ul>"},{"location":"IS1108/Automation%20and%20Autonomous%20Systems/#considerations-of-ethical-automation","title":"Considerations of ethical automation","text":"<p>There are many considerations that need to be addressed when making Autonomous Systems. Here's a few: - Safety - Privacy and data security - Liability - Effects to the incumbent workforce - Autonomy and independence - Social connectedness and human interaction - Objectification and infantilisation - Deception and anthromorphisation - Social justice, etc</p>"},{"location":"IS1108/Consequentialist/","title":"Consequentialist","text":"<p>IS1108 Home Page | Professional Ethics</p>"},{"location":"IS1108/Consequentialist/#process","title":"Process","text":"<p>What kind of an outcome should I produce (or try to produce)?</p>"},{"location":"IS1108/Consequentialist/#focus","title":"Focus","text":"<p>The ends justify the means.  </p>"},{"location":"IS1108/Consequentialist/#definition-of-ethical-conduct","title":"Definition of ethical conduct","text":"<p>Ethical conduct is the action that will achieve the best consequences</p>"},{"location":"IS1108/Consequentialist/#motivation","title":"Motivation","text":"<p>Aims to produce the most \"good\"</p>"},{"location":"IS1108/Consequentialist/#example","title":"Example","text":"<p>If telling a lie would save a life, a consequentialist would do so as \"saving a life\" does the most good, even if telling a lie is wrong.</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/","title":"Data Protection in ICT","text":"<p>IS1108 Home Page</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#personal-data-protection-act-pdpa","title":"Personal Data Protection Act (PDPA)","text":"<p>Personal Data is data, whether correct or not, that can be used to identify an individual either  - directly from the data - in conjunction with other data available to the organisation</p> <p>The following are defined under the PDPA</p> <ul> <li>Individual: A natural person, both alive or dead. </li> <li>Organisation: Any individual, company, association or body of persons, corporate or unincorporated, whether or not formed or recognised under the law of Singapore, or resident, or having an office or a place of business, in Singapore.<ul> <li>Organisations can include both Businesses and non-profits</li> </ul> </li> </ul> <p>Business Contact Information is information (such as name, contacts, job position) not provided by the individual solely for personal purposes. Organisations do not need to seek consent before collecting, using or disclosing any BCI. </p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#data-intermediary","title":"Data Intermediary","text":"<p>Organisation that processes data on behalf of another organisation but does not include an employee of the other organisation. Processing is the carrying out of the set of any of the following operations: - recording  - holding - organisation, adaptation or alteration - retrieval  - combination  - transmission  - erasure or destruction </p> <p>The contracted DI cannot use personal information for any other purpose apart from the one that had already been stated. </p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#scope-of-pdpa","title":"Scope of PDPA","text":""},{"location":"IS1108/Data%20Protection%20in%20ICT/#obligations-under-pdpa","title":"Obligations under PDPA","text":"<p>PDPA = DP + DNC (do not call registry / marketing messages)</p> <p></p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#consent-obligation","title":"Consent obligation","text":"<p>Organisations must obtain consent from individuals to collect, use and disclose their PD, unless exception applies. Individuals should be able to withdraw consent and organisations should inform them of the likely consequences of withdrawal.</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#purpose-limitation-obligation","title":"Purpose Limitation Obligation","text":"<p>The reason to collect data must be clear and have a strict limitation. It cannot be unlimited. The purpose must also have explicit consent obtained. Lastly, the purpose should be \"reasonable\".</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#notification-obligation","title":"Notification Obligation","text":"<p>Inform individuals of the purpose for data collection, use or disclosure of their PD. This should be done before and when entering into a contract. There is not pre-determined amount that individuals should be informed of, but it must be easy to understand and the main points must be highlighted. </p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#accuracy-obligation","title":"Accuracy Obligation","text":"<p>Personal data collected must be accurate and complete if - Data used to make a decision that affects the person - Data is disclosed to another organisation</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#protection-obligation","title":"Protection Obligation","text":"<p>Data must be secured. DI must comply with this obligation.</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#retention-limitation-obligation","title":"Retention Limitation Obligation","text":"<p>Retain PD only for as long as needed for the purposes of their collection.  - No stipulated retention period - Data intermediary must comply with this obligation</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#transfer-limitation-obligation","title":"Transfer limitation obligation","text":"<p>Transfer of personal data out of Singapore must comply with PDPA - Standard of protection is comparable to PDPA - PD is used in accordance with PDPA while overseas</p>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#access-and-correction-obligation","title":"Access and correction obligation","text":"<ul> <li>Request channels available</li> <li>Responding within 30 days</li> <li>Reasonable access fees</li> <li>PD used or disclosed for the past 1 year</li> </ul>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#accountability-obligation","title":"Accountability obligation","text":"<ol> <li>Appoint Data Protection Officers</li> <li>Implement the necessary policies and procedures</li> <li>Make information about its policies publicly available</li> <li>Make DPO contact details available to the public</li> </ol>"},{"location":"IS1108/Data%20Protection%20in%20ICT/#data-breach-notification-obligation","title":"Data breach notification obligation","text":"<ul> <li>Conduct assessment<ul> <li>Significant scale</li> <li>Significant harm</li> <li>Within 30 days</li> </ul> </li> <li>Notify<ul> <li>PDPC</li> <li>Affected individuals</li> <li>Within 3 days</li> </ul> </li> <li>Data intermediary must comply with this obligation</li> </ul>"},{"location":"IS1108/Duty/","title":"Duty","text":"<p>IS1108 Home Page | Professional Ethics</p>"},{"location":"IS1108/Duty/#process","title":"Process","text":"<p>What are my obligations in this situation? What are the things that I should never do?</p>"},{"location":"IS1108/Duty/#focus","title":"Focus","text":"<p>My duty is what dictates I should do prior to the emergence of a situation.</p>"},{"location":"IS1108/Duty/#definition-of-ethical-conduct","title":"Definition of ethical conduct","text":"<p>Ethical conduct involves always doing the right thing: never failing to do ones duty. </p>"},{"location":"IS1108/Duty/#motivation","title":"Motivation","text":"<p>Aims to perform the \"right\" action</p>"},{"location":"IS1108/Duty/#example","title":"Example","text":"<p>If you are a soldier, protecting your nation is your duty. This means that in the event of war, taking a life while morally reprehensible, should be what is done as it is your duty. </p>"},{"location":"IS1108/IS1108%20Home%20Page/","title":"ComputerScience #Ethics #Fluff","text":"<p>A compilation of notes for IS1108. Enjoy!</p> <p>Table of Contents  - Professional Ethics - Artificial Intelligence Ethics and Governance - Automation and Autonomous Systems - Data Protection in ICT</p>"},{"location":"IS1108/Professional%20Ethics/","title":"Professional Ethics","text":"<p>IS1108 Home Page </p> <p>Computing professionals have an ethical responsibility towards different stakeholders - each coming with their own ethical concerns. </p> Stakeholder Ethical concern Customer and users Social impact, Quality &amp; Risks, Data Privacy Employers Intellectual Property, Conflict of interest Other Professionals Plagiarism, Professional Standards and Conduct, Mentorship Public Safety, Whistleblowing <p>The question is how do we go about to weigh each of these ethical considerations against one another? </p>"},{"location":"IS1108/Professional%20Ethics/#ethical-frameworks","title":"Ethical Frameworks","text":"<ul> <li>Consequentialist</li> <li>Duty </li> <li>Virtue</li> </ul>"},{"location":"IS1108/Professional%20Ethics/#application-for-computing-professionals","title":"Application for Computing Professionals","text":""},{"location":"IS1108/Professional%20Ethics/#professional-ethics","title":"Professional Ethics","text":"<ul> <li>Honesty </li> <li>Trustworthiness  </li> <li>Loyalty  </li> <li>Respect for others  </li> <li>Adherence to the law  </li> <li>Doing good and avoiding harm to others  </li> <li>Accountability</li> </ul>"},{"location":"IS1108/Professional%20Ethics/#using-the-ethical-frameworks","title":"Using the Ethical Frameworks","text":"<p>Scenario: You are a software engineer working for a company that develops autonomous driving software. You're currently working on an update to the decision-making algorithms for emergency scenarios. A recently surfaced issue is the \"trolley problem,\" a hypothetical situation where the autonomous vehicle must choose between two harmful outcomes: - The car, to avoid a group of five pedestrians who suddenly appear in its path, could swerve into a wall, likely seriously injuring the single passenger inside. - The car could continue on its path, likely injuring or even killing the five pedestrians.  </p> <p>Should you modify the algorithm to always prioritize the lives of multiple people over one, even if that one is the passenger?</p>"},{"location":"IS1108/Professional%20Ethics/#possible-solutions","title":"Possible Solutions","text":""},{"location":"IS1108/Professional%20Ethics/#option-a","title":"Option A","text":"<p>Implement the change, as protecting multiple lives over one is ethically permissible, even if it harms the passenger.</p>"},{"location":"IS1108/Professional%20Ethics/#option-b","title":"Option B","text":"<p>Reject the change, as it's not ethically permissible to directly harm the passenger, regardless of the potential benefits.</p>"},{"location":"IS1108/Professional%20Ethics/#option-c","title":"Option C","text":"<p>Implement the change, but also inform all potential customers about this feature, allowing them to make an informed decision.</p>"},{"location":"IS1108/Professional%20Ethics/#option-d","title":"Option D","text":"<p>Reject the change and seek a third solution that doesn't risk harming either the passenger or pedestrians.</p>"},{"location":"IS1108/Professional%20Ethics/#consequentialist","title":"Consequentialist:","text":"<p>This theory would likely favor Option A, as it prioritizes the greatest good for the greatest number (i.e., saving multiple pedestrians over one passenger).</p>"},{"location":"IS1108/Professional%20Ethics/#duty","title":"Duty:","text":"<p>This theory focuses on duties and rules. It might lean towards Option B because it emphasizes the autonomous vehicle's duty not to harm its passenger. However, a deontologist could also argue for Option D, seeking a solution that fulfills the duty not to harm anyone if possible</p>"},{"location":"IS1108/Professional%20Ethics/#virtue","title":"Virtue:","text":"<p>This perspective focuses on character and the kinds of virtues (or moral character traits) one should cultivate. A virtue ethicist might argue for Option C or Option D, as these options show a concern for transparency, respect for all parties involved, and a willingness to seek better solutions.</p>"},{"location":"IS1108/Professional%20Ethics/#principle-of-double-effects-pde","title":"Principle of Double Effects (PDE)","text":"<p>Definition: if an action has two possible outcomes - one good and one bad - then it is still permissible to perform if the actor intends only for the good outcome and takes reasonable steps to prevent or minimise the bad outcome. </p>"},{"location":"IS1108/Virtue/","title":"Virtue","text":"<p>IS1108 Home Page | Professional Ethics</p>"},{"location":"IS1108/Virtue/#process","title":"Process","text":"<p>What are the morals and ethics that I want to exemplify? What will my actions show about my character?</p>"},{"location":"IS1108/Virtue/#focus","title":"Focus","text":"<p>My actions are defined by the person (or organisation) I want to be.</p>"},{"location":"IS1108/Virtue/#definition-of-ethical-conduct","title":"Definition of ethical conduct","text":"<p>Ethical conduct involves always doing whatever a fully ethical person would do. </p>"},{"location":"IS1108/Virtue/#motivation","title":"Motivation","text":"<p>Aims to develop ones character.</p>"},{"location":"IS1108/Virtue/#example","title":"Example","text":"<p>If lying is unacceptable to you, you may not lie regardless of the circumstance as you want to become someone that exemplifies honesty. </p>"},{"location":"blog/","title":"Blog","text":""}]}